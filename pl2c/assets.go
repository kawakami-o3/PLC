package main

import (
	"time"

	"github.com/deadcheat/goblet"
)

// Assets a generated file system
var Assets = goblet.NewFS(
	map[string][]string{
		"/templates": []string{
			"common.c",
		},
	},
	map[string]*goblet.File{
		"/templates":          goblet.NewFile("/templates", nil, 0x800001ed, time.Unix(1532024171, 1532024171710522062)),
		"/templates/common.c": goblet.NewFile("/templates/common.c", []byte(_Assetsefa8d46f8b5cc70fc7d3d096c366747abdf35ab5), 0x1a4, time.Unix(1532024171, 1532024171710522062)),
	},
)

// binary data
var (
	_Assetsefa8d46f8b5cc70fc7d3d096c366747abdf35ab5 = "#include<stdarg.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define INIT_SIZE 8\n\nvoid printLine() {\n\tprintf(\"%d\\n\", __LINE__);\n}\n\ntypedef struct {\n\tint nalloc;\n\tint length;\n\tchar *chars;\n} String;\n\nString *make_string() {\n\tString *s = malloc(sizeof(String));\n\ts->chars = malloc(INIT_SIZE);\n\ts->nalloc = INIT_SIZE;\n\ts->length = 0;\n\ts->chars[0] = '\\0';\n\treturn s;\n}\n\nstatic void realloc_string(String *s) {\n\tint newsize = s->nalloc * 2;\n\tchar *chars = malloc(newsize);\n\tstrcpy(chars, s->chars);\n\ts->chars = chars;\n\ts->nalloc = newsize;\n}\n\nvoid string_append(String *s, char c) {\n\tif (s->nalloc == (s->length + 1)) {\n\t\trealloc_string(s);\n\t}\n\ts->chars[s->length++] = c;\n\ts->chars[s->length] = '\\0';\n}\n\nvoid string_appendf(String *s, char *fmt, ...) {\n\tva_list args;\n\tfor (;;) {\n\t\tint avail = s->nalloc - s->length;\n\t\tva_start(args, fmt);\n\t\tint written = vsnprintf(s->chars + s->length, avail, fmt, args);\n\t\tva_end(args);\n\t\tif (avail <= written) {\n\t\t\trealloc_string(s);\n\t\t\tcontinue;\n\t\t}\n\t\ts->length += written;\n\t\treturn;\n\t}\n}\n\nenum Type {\n\tNIL,\n\tINT,\n\tSTR,\n\tPROC\n};\n\nstruct List;\n\ntypedef struct {\n\tint type;\n\n\tint i;\n\tString *str;\n\tstruct List *(*proc)(struct List*);\n} Atom;\n\ntypedef struct List {\n\tAtom *atom;\n\n\tstruct List *car;\n\tstruct List *cdr;\n} List;\n\nList *make_list();\nList *make_int(int i);\nList *car(List *lst);\n\nList *nil;\nList *t;\n\nAtom *make_atom() {\n\tAtom *a = malloc(sizeof(Atom));\n\treturn a;\n}\n\nList *make_list() {\n\tList *lst = malloc(sizeof(List));\n\tlst->atom = NULL;\n\tlst->car = NULL;\n\tlst->cdr = NULL;\n\treturn lst;\n}\n\nList *make_int(int i) {\n\tAtom *atom = make_atom();\n\tatom->type = INT;\n\tatom->i = i;\n\n\tList *lst = make_list();\n\tlst->atom = atom;\n\treturn lst;\n}\n\nList *make_symbol(char *chars) {\n\tAtom *atom = make_atom();\n\tatom->type = STR;\n\tatom->str = make_string();\n\tstring_appendf(atom->str, \"%s\", chars);\n\n\tList *lst = make_list();\n\tlst->atom = atom;\n\treturn lst;\n}\n\nList *make_lambda(List *(*proc)(struct List*)) {\n\tAtom *atom = make_atom();\n\tatom->type = PROC;\n\tatom->proc = proc;\n\n\tList *lst = make_list();\n\tlst->atom = atom;\n\treturn lst;\n}\n\nList *eq(List *a, List *b) {\n\tif (a->atom != NULL && b->atom != NULL) {\n\t\tif (a->atom->type != b->atom->type) {\n\t\t\treturn nil;\n\t\t} else if (a->atom->type == INT) {\n\t\t\treturn a->atom->i == b->atom->i ? t : nil;\n\t\t} else if (a->atom->type == STR) {\n\t\t\treturn strcmp(a->atom->str->chars, b->atom->str->chars) == 0 ? t : nil;\n\t\t} else if (a->atom->type == PROC) {\n\t\t\treturn a->atom->proc == b->atom->proc ? t : nil;\n\t\t}\n\t} else if (a->car != NULL && b->car != NULL) {\n\t\tif (eq(a->car, b->car)) {\n\t\t\tif (a->cdr != NULL && b->cdr != NULL) {\n\t\t\t\treturn eq(a->cdr, b->cdr);\n\t\t\t} else if (a->cdr == NULL && b->cdr == NULL) {\n\t\t\t\treturn t;\n\t\t\t} else {\n\t\t\t\treturn nil;\n\t\t\t}\n\t\t\treturn nil;\n\t\t} else {\n\t\t\treturn nil;\n\t\t}\n\t} else {\n\t\treturn nil;\n\t}\n}\n\nvoid to_string(String *str, List *lst) {\n\tif (lst == NULL) {\n\t\treturn;\n\t} else if (lst->atom == NULL) {\n\t\tstring_appendf(str, \"(\");\n\t\tto_string(str, lst->car);\n\t\tstring_appendf(str, \" \");\n\t\tif (lst->cdr != NULL && lst->cdr != nil) {\n\t\t\tto_string(str, lst->cdr);\n\t\t}\n\t\tstring_appendf(str, \")\");\n\t} else {\n\t\tswitch(lst->atom->type) {\n\t\t\tcase INT:\n\t\t\t\tstring_appendf(str, \" %d\", lst->atom->i);\n\t\t\t\tbreak;\n\t\t\tcase STR:\n\t\t\t\tstring_appendf(str, \" %s\", lst->atom->str->chars);\n\t\t\t\tbreak;\n\t\t\tcase PROC:\n\t\t\t\tstring_appendf(str, \" PROC\");\n\t\t\t\tbreak;\n\t\t\tcase NIL:\n\t\t\t\tstring_appendf(str, \" nil\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstring_appendf(str, \" ???\");\n\t\t}\n\t}\n}\n\n/*\nList *callProc(List *proc, int argc, ...) {\n\tva_list args;\n\tList *ret;\n\tList *lst = make_list();\n\tva_start(args, argc);\n\tfor (int i=0 ; i<argc ; i++) {\n\t\tList *a = va_arg(args, (List*));\n\t\tlst = cons(a, lst);\n\t}\n\tva_end(args);\n\treturn proc.proc(lst);\n}\n*/\n\nvoid printList(List *lst) {\n\tString *s = make_string();\n\tto_string(s, lst);\n\tprintf(\"%s\\n\", s->chars);\n}\n\nList *car(List *lst) {\n\tif (lst->car == NULL) {\n\t\tprintf(\"error\");\n\t\texit(-1);\n\t}\n\treturn lst->car;\n}\n\nList *cdr(List *lst) {\n\treturn lst->cdr;\n}\n\nList *cons(List *a, List *b) {\n\tList *lst = make_list();\n\tlst->car = a;\n\tlst->cdr = b;\n\treturn lst;\n}\n\nList *nth(List *lst, int i) {\n\tif (i <= 0) {\n\t\treturn lst->car;\n\t}\n\tif (lst->cdr == NULL) {\n\t\treturn NULL;\n\t}\n\treturn nth(lst->cdr, i-1);\n}\n\nList *plc_add(List *lst) {\n\tint i = 0;\n\n\tList *a = lst->car;\n\tList *d = lst->cdr;\n\twhile (a != NULL) {\n\t\ti += a->atom->i;\n\t\ta = d->car;\n\t\td = d->cdr;\n\t}\n\n\treturn make_int(i);\n}\n\nList *plc_sub(List *lst) {\n\tList *a = lst->car;\n\tList *d = lst->cdr;\n\tint i = a->atom->i;\n\n\ta = d->car;\n\td = d->cdr;\n\twhile (a != NULL) {\n\t\ti -= a->atom->i;\n\t\ta = d->car;\n\t\td = d->cdr;\n\t}\n\n\treturn make_int(i);\n}\n\nvoid init_common() {\n\tnil = make_list();\n\tnil->atom = make_atom();\n\tnil->atom->type = NIL;\n\tnil->atom->i = 0;\n\n\tt = make_list();\n\tt->atom = make_atom();\n\tnil->atom->type = INT;\n\tt->atom->i = 1;\n}\n"
)

